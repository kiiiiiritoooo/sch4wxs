<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <link rel="icon" type="image/png" href="../src/icon.svg">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Happy Birthday</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Noto+Serif+SC:wght@500;700&display=swap" rel="stylesheet">
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1640029074/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.6.1629159505/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248257/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>

    <style>
        :root { --bg-gradient: radial-gradient(circle at center, #1a0b1a 0%, #000000 100%); }
        body { 
            margin: 0; overflow: hidden; 
            background-color: #000000; background-image: var(--bg-gradient); 
            font-family: 'Noto Serif SC', serif; color: white; 
            user-select: none; -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; cursor: grab; }
        #canvas-container:active { cursor: grabbing; }
        
        /* ç¿»è½¬å¡ç‰‡ */
        .flip-card { background-color: transparent; perspective: 1000px; }
        .flip-card-inner {
            position: relative; width: 100%; height: 100%; text-align: center;
            transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-style: preserve-3d;
        }
        .flip-card.flipped .flip-card-inner { transform: rotateY(180deg); }
        .flip-card-front, .flip-card-back {
            position: absolute; width: 100%; height: 100%;
            -webkit-backface-visibility: hidden; backface-visibility: hidden;
            border-radius: 1.2rem; overflow: hidden;
        }
        .flip-card-back { transform: rotateY(180deg); }

        /* UI å±‚ */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 1.5rem; box-sizing: border-box; transition: opacity 0.5s; }
        .interactive-element { pointer-events: auto; cursor: pointer; }
        .input_video { display: none; }
        .glass-panel { background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 1.5rem; box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5); }
        
        /* å¯åŠ¨é¡µæ ·å¼ */
        #start-overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.6); 
            z-index: 9999; 
            display: flex; justify-content: center; align-items: center; 
            pointer-events: auto;
            transition: opacity 0.8s ease, visibility 0.8s;
        }
        #start-overlay.hidden { opacity: 0; visibility: hidden; pointer-events: none; }
        
        .start-card {
            background: rgba(20, 10, 20, 0.75);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 105, 180, 0.3);
            box-shadow: 0 0 50px rgba(255, 105, 180, 0.2);
        }

        #blow-meter-container { position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%); width: 280px; height: 12px; background: rgba(255,255,255,0.1); border-radius: 10px; overflow: hidden; opacity: 0; transition: opacity 0.5s; }
        #blow-meter-bar { height: 100%; width: 0%; background: linear-gradient(90deg, #ff9a9e 0%, #ff69b4 100%); border-radius: 10px; transition: width 0.1s linear; box-shadow: 0 0 15px #ff69b4; }
        #blow-hint { position: absolute; bottom: 18%; width: 100%; text-align: center; font-size: 14px; color: rgba(255,255,255,0.8); text-shadow: 0 2px 4px rgba(0,0,0,0.8); opacity: 0; transition: opacity 0.5s; }

        #surprise-layer { position: absolute; inset: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 80; pointer-events: none; transition: background 0.5s ease; }
        #surprise-layer.hidden { display: none !important; }
        #surprise-layer.active { pointer-events: auto; background: rgba(0,0,0,0.4); backdrop-filter: blur(4px); }

        .font-handwriting { font-family: 'Dancing Script', cursive; }
        .pop-in { animation: popIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards; }
        .animate-float { animation: float 3s ease-in-out infinite; }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        .safe-click-area { z-index: 90; position: relative; touch-action: manipulation; }
        .neon-text { text-shadow: 0 0 10px rgba(255,105,180,0.7), 0 0 20px rgba(255,105,180,0.5); }

        #floating-gift-btn {
            position: absolute; bottom: 30px; right: 30px; z-index: 200; width: 60px; height: 60px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border: 1px solid rgba(255, 105, 180, 0.5);
            display: flex; justify-content: center; align-items: center; font-size: 30px; cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 105, 180, 0.4); animation: float-btn 3s ease-in-out infinite;
            transition: transform 0.3s, background 0.3s; pointer-events: auto;
        }
        #floating-gift-btn:hover { transform: scale(1.1) rotate(10deg); background: rgba(255, 105, 180, 0.3); }
        #floating-gift-btn.hidden { display: none !important; }
        @keyframes float-btn { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }

        #settings-panel {
            position: absolute; top: 80px; right: 20px; width: 140px;
            background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 12px;
            padding: 15px; z-index: 50; display: none; 
            flex-direction: column; gap: 10px; pointer-events: auto;
        }
        .color-control { display: flex; align-items: center; justify-content: space-between; font-size: 12px; color: #ddd; }
        .color-control input { width: 30px; height: 20px; border: none; border-radius: 4px; cursor: pointer; background: transparent; }

        #top-banner {
            position: absolute; top: 15%; left: 0; width: 100%;
            text-align: center; pointer-events: none; z-index: 5;
            animation: float-banner 4s ease-in-out infinite;
        }
        #top-banner.hidden { display: none !important; }
        .banner-text {
            font-family: 'Dancing Script', cursive;
            background: linear-gradient(to right, #ff9a9e, #fad0c4, #fad0c4, #a18cd1, #fbc2eb);
            -webkit-background-clip: text; background-clip: text; color: transparent;
            filter: drop-shadow(0 0 10px rgba(255,192,203,0.8));
        }
        @keyframes float-banner { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }

        #protocol-warning {
            position: fixed; top: 0; left: 0; width: 100%; background: #ff4444; color: white;
            text-align: center; padding: 10px; z-index: 10000; font-size: 14px; display: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        
        #cam-preview-container {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #cam-preview-container:hover {
            transform: scale(1.05);
            opacity: 1;
        }
        
        @keyframes neon-pulse {
            0%, 100% { text-shadow: 0 0 10px rgba(255,105,180,0.7), 0 0 20px rgba(255,105,180,0.5); }
            50% { text-shadow: 0 0 20px rgba(255,105,180,0.9), 0 0 30px rgba(255,105,180,0.7), 0 0 40px rgba(255,105,180,0.5); }
        }
        .neon-pulse { animation: neon-pulse 2s infinite; }

        /* éšè—çš„æ—¥å¿—å®¹å™¨ */
        #debug-console { display: none; }

        /* æ»šåŠ¨æ–‡å­—åŒºåŸŸæ ·å¼ */
        .scrollable-text {
            max-height: 240px; /* é™åˆ¶é«˜åº¦ */
            overflow-y: auto;  /* å…è®¸å‚ç›´æ»šåŠ¨ */
            padding-right: 10px; /* ç»™æ»šåŠ¨æ¡ç•™ç‚¹ç©º */
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: rgba(255,105,180,0.5) transparent; /* Firefox */
        }
        /* Chrome/Safari æ»šåŠ¨æ¡æ ·å¼ */
        .scrollable-text::-webkit-scrollbar {
            width: 4px;
        }
        .scrollable-text::-webkit-scrollbar-track {
            background: transparent;
        }
        .scrollable-text::-webkit-scrollbar-thumb {
            background-color: rgba(255, 105, 180, 0.5);
            border-radius: 10px;
        }
    </style>
</head>
<body>
    
    <div id="debug-console"></div>

    <div id="protocol-warning">
        âš ï¸ æ£€æµ‹åˆ°æ‚¨ç›´æ¥æ‰“å¼€äº†HTMLæ–‡ä»¶ (file://)ã€‚<br>æ‘„åƒå¤´å’Œéº¦å…‹é£å°†è¢«æ‹¦æˆªã€‚<br>
        <b>å¯ä»¥ä½¿ç”¨é”®ç›˜å¿«æ·é”®ï¼šæŒ‰ S é”®æ•£å¼€è›‹ç³•ï¼ŒæŒ‰ R é”®æ¢å¤è›‹ç³•ï¼ŒæŒ‰ P é”®æ˜¾ç¤º/éšè—ç…§ç‰‡</b><br>
        <b>æˆ–ä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨ï¼šåœ¨ VS Code ä¸­å®‰è£… "Live Server" æ’ä»¶å¹¶ä½¿ç”¨ "Open with Live Server" è¿è¡Œã€‚</b>
    </div>

    <audio id="bgm" loop>
        <source src="./src/happy-birthday-155461.mp3" type="audio/mpeg">
    </audio>

    <video class="input_video" playsinline></video>
    <div id="canvas-container"></div>
    
    <button id="floating-gift-btn" class="hidden safe-click-area" title="æŸ¥çœ‹ç¥ç¦">ğŸ</button>

    <!-- å¯åŠ¨é¡µ -->
    <div id="start-overlay">
        <div class="text-center max-w-md p-8 glass-panel start-card mx-4 animate-float">
            <h1 class="text-6xl mb-2 font-handwriting text-transparent bg-clip-text bg-gradient-to-r from-pink-300 to-purple-400 drop-shadow-lg">Happy Birthday</h1>
            <!-- <h2 class="text-4xl mb-6 font-bold text-white tracking-widest neon-text">ç²‰å§</h2> -->
            <div class="space-y-4 text-gray-200 text-lg mb-8 font-light">
                <p>ğŸ‘‹ <b>å¯¹ç€é•œå¤´ ä¸¾èµ·åŒæ‰‹</b> å”¤é†’é­”æ³•</p>
                <p>ğŸ’¨ <b>æŒç»­å¹æ°”</b> è®¸ä¸‹å¿ƒæ„¿</p>
            </div>
            <button id="start-btn" class="safe-click-area px-12 py-4 bg-gradient-to-r from-pink-600 to-purple-700 rounded-full font-bold text-xl hover:scale-105 active:scale-95 transition transform shadow-[0_0_20px_rgba(255,105,180,0.5)] text-white border border-white/20 cursor-pointer z-50">
                è¿›å…¥é­”æ³•ä¸–ç•Œ
            </button>
            <div id="loading-text" class="hidden mt-4 text-pink-300 text-sm">æ­£åœ¨ç¼–ç»‡æ˜Ÿå…‰...</div>
        </div>
    </div>

    <div id="blow-hint"><p class="text-lg font-bold text-pink-200 mb-1">ğŸ¤ å¯¹ç€éº¦å…‹é£å¹æ°”</p><p class="text-xs text-gray-400">(å¦‚æœéº¦å…‹é£ä¸çµå¯ä»¥å°è¯•ç”µè„‘é•¿æŒ‰ç©ºæ ¼ Â· æ‰‹æœºé•¿æŒ‰å±å¹•)</p></div>
    <div id="blow-meter-container"><div id="blow-meter-bar"></div></div>

    <div id="top-banner" class="hidden">
        <h1 class="text-6xl md:text-8xl banner-text">Happy Birthday</h1>
        <p class="text-pink-200/70 text-lg mt-2 tracking-widest uppercase">Best Wishes for You</p>
    </div>

    <!-- UI å±‚ -->
    <div id="ui-layer" style="display: none;">
        <div class="flex justify-between items-start w-full">
            <div class="glass-panel px-4 py-2">
                <div id="status-dot" class="inline-block w-2 h-2 rounded-full bg-red-500 mr-2 shadow-[0_0_8px_red]"></div>
                <span id="status-text" class="text-xs md:text-sm text-gray-300 tracking-wider">SYSTEM READY</span>
            </div>
            <div class="flex gap-2">
                <button id="settings-toggle" class="interactive-element p-3 glass-panel hover:bg-white/20 transition rounded-full active:scale-90 text-sm">ğŸ¨</button>
                <button id="music-btn" class="interactive-element p-3 glass-panel hover:bg-white/20 transition rounded-full active:scale-90">ğŸµ</button>
            </div>
        </div>
        
        <div id="settings-panel">
            <div class="color-control"><span>åº•å±‚é¢œè‰²</span><input type="color" id="picker-bottom" value="#FF69B4"></div>
            <div class="color-control"><span>é¡¶å±‚é¢œè‰²</span><input type="color" id="picker-top" value="#FFB6C1"></div>
            <div class="color-control"><span>å¥¶æ²¹é¢œè‰²</span><input type="color" id="picker-cream" value="#FFFFFF"></div>
        </div>

        <div id="center-instruction" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center pointer-events-none w-full z-0">
            <div class="flex items-center justify-center gap-4 mb-2">
                <span id="hand-icon" class="text-6xl animate-bounce">ğŸ‘‹</span>
                <h2 id="instruction-text" class="text-6xl md:text-8xl font-bold text-white neon-pulse transition-all duration-700">ä¸¾èµ·åŒæ‰‹</h2>
            </div>
            <p id="sub-instruction" class="mt-4 text-xl md:text-2xl text-pink-200/80 font-light tracking-[0.3em]">è®©é­”æ³•å‘ç”Ÿ</p>
            <!-- è‡ªåŠ¨å€’æ•°æç¤ºæ–‡å­— -->
            <p id="auto-countdown-text" class="mt-4 text-sm text-pink-200/60 font-light tracking-wider animate-pulse hidden"></p>
        </div>

        <!-- æ‘„åƒå¤´é¢„è§ˆæ¡† -->
        <div id="cam-preview-container" class="absolute bottom-6 left-6 z-50 opacity-90 hover:opacity-100">
            <div class="glass-panel p-2 rounded-xl border border-white/10 shadow-[0_8px_32px_rgba(0,0,0,0.5)]">
                <div class="relative w-36 h-28 bg-black/40 rounded-lg overflow-hidden border border-white/5">
                     <canvas id="output_canvas" width="160" height="120" class="w-full h-full object-cover transform scale-x-[-1]"></canvas>
                     <div class="absolute top-2 right-2 flex items-center gap-1 bg-black/60 px-1.5 py-0.5 rounded-full backdrop-blur-sm">
                        <div id="cam-status-dot" class="w-1.5 h-1.5 rounded-full bg-red-500 transition-colors duration-300"></div>
                        <span id="cam-status-text" class="text-[8px] text-red-400 font-mono">NO HAND</span>
                     </div>
                </div>
                <div class="text-center mt-1.5">
                    <p class="text-[10px] text-pink-200/70 tracking-widest uppercase scale-90">Camera View</p>
                </div>
            </div>
        </div>
    </div>

    <!-- ç…§ç‰‡å±•ç¤ºå±‚ -->
    <div id="photo-layer" class="hidden" style="position: absolute; inset: 0; z-index: 100; pointer-events: none;">
        <img id="display-photo" src="" alt="Photo" style="position: absolute; max-width: 300px; max-height: 300px; border-radius: 12px; box-shadow: 0 0 30px rgba(255,105,180,0.8); opacity: 0; transition: opacity 0.3s, transform 0.3s; transform: scale(0.8);">
    </div>

    <!-- æƒŠå–œå±‚ -->
    <div id="surprise-layer" class="hidden">
        <button id="reveal-btn" class="safe-click-area hidden px-10 py-5 bg-white text-pink-600 rounded-full font-bold text-2xl shadow-[0_0_60px_rgba(255,105,180,0.8)] hover:scale-105 transition-transform duration-300 animate-float">ğŸ æ‰“å¼€ç¤¼ç‰©</button>
        
        <!-- å¡ç‰‡å®¹å™¨ -->
        <div id="flip-card-container" class="hidden flip-card w-full max-w-sm md:max-w-md aspect-[3/4] mx-6 pop-in">
            <div class="flip-card-inner">
                
                <!-- æ­£é¢ï¼šå¼•å¯¼å¼€å¯ -->
                <div class="flip-card-front glass-panel bg-gradient-to-br from-pink-500/40 to-purple-600/40 border border-white/30 p-1">
                    <div class="bg-black/80 rounded-[1rem] p-6 h-full flex flex-col backdrop-blur-md">
                        <div class="w-full aspect-[4/3] bg-gray-800 rounded-lg mb-6 overflow-hidden relative border border-white/10 shadow-inner">
                            <img src="https://bpic.588ku.com/Templet_origin_pic/05/19/43/8c971b1364922e551b4fbccb2d5719d2.jpg" class="w-full h-full object-cover" alt="Gift">
                            <div class="absolute bottom-3 left-4 text-white/90 font-handwriting text-2xl">Happy Birthday!</div>
                        </div>
                        <div class="text-center mt-auto mb-8">
                            <p class="text-gray-300 mb-6 font-light leading-relaxed">è¿™ä¸ä»…ä»…æ˜¯ä¸€åœºæ•°å­—çƒŸèŠ±ï¼Œ<br>æ›´æ˜¯ä¸ºä½ å‡†å¤‡çš„ä¸“å±æ—¶åˆ»ã€‚</p>
                            <button id="next-surprise-btn" class="safe-click-area w-full py-3 bg-gradient-to-r from-pink-600 to-purple-700 rounded-xl font-bold text-white shadow-lg hover:brightness-110 active:scale-95 transition">What's the surprise? âœ¨</button>
                        </div>
                    </div>
                </div>

                <!-- èƒŒé¢ï¼šç¥ç¦å†…å®¹ (åˆ†é¡µæ˜¾ç¤º) -->
                <div class="flip-card-back glass-panel bg-gradient-to-br from-purple-500/40 to-blue-600/40 border border-white/30 p-1">
                    <div class="bg-black/90 rounded-[1rem] p-8 h-full flex flex-col items-center justify-center backdrop-blur-md">
                        
                        <!-- ç¬¬ä¸€é¡µï¼šç”Ÿæ—¥ç¥ç¦ (å¸¦ç…§ç‰‡) -->
                        <div id="card-page-1" class="w-full h-full flex flex-col">
                            <div class="mb-4 text-5xl animate-bounce text-center">ğŸ’Œ</div>
                            <h3 class="text-2xl font-bold text-pink-300 mb-6 font-handwriting text-center">è‡´æœ€ç‰¹åˆ«çš„ä½ </h3>
                            <div id="typewriter-text-1" class="text-left text-gray-200 space-y-4 font-light leading-7 text-sm md:text-base border-l-2 border-pink-500/50 pl-4 mb-4 flex-grow scrollable-text"></div>
                            
                            <button id="to-page-2-btn" class="safe-click-area px-6 py-2 mt-auto rounded-full bg-white/10 text-pink-200 hover:bg-white/20 transition text-sm flex items-center justify-center mx-auto">
                                è¿˜æœ‰è¯å¯¹ä½ è¯´... <span class="ml-2">ğŸ‘‰</span>
                            </button>
                        </div>

                        <!-- ç¬¬äºŒé¡µï¼šå¿«é€’ä¿¡æ¯ (çº¯æ–‡å­—ï¼Œå¸¦æ»šåŠ¨) -->
                        <div id="card-page-2" class="w-full h-full flex flex-col hidden">
                            <h3 class="text-xl font-bold text-purple-300 mb-4 font-handwriting text-center mt-2">ä¸€ç‚¹å°å°çš„æ­‰æ„</h3>
                            <!-- æ»šåŠ¨åŒºåŸŸ -->
                            <div id="typewriter-text-2" class="text-left text-gray-200 space-y-3 font-light leading-6 text-sm md:text-base border-l-2 border-purple-500/50 pl-4 mb-4 flex-grow scrollable-text h-full"></div>
                            
                            <button id="close-card-btn" class="safe-click-area px-8 py-2 mt-auto rounded-full border border-white/30 text-gray-300 hover:bg-white/10 hover:text-white transition text-sm mx-auto">
                                æ”¶èµ·å¡ç‰‡
                            </button>
                        </div>

                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- è°ƒè¯•æ—¥å¿—å·¥å…· ---
        const debugConsole = document.getElementById('debug-console');
        function log(msg) {
            if (debugConsole) {
                const time = new Date().toLocaleTimeString();
                debugConsole.innerHTML += `[${time}] ${msg}<br>`;
            }
            console.log(msg);
        }

        const IS_MOBILE = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        if (window.location.protocol === 'file:') {
            document.getElementById('protocol-warning').style.display = 'block';
        }

        // --- å…¨å±€å˜é‡ä¸é…ç½® ---
        const CAKE_THEME = { bottom: "#FF69B4", top: "#FFB6C1", cream: "#FFFFFF" };
        const VISUAL_CONFIG = { particleCount: IS_MOBILE ? 4000 : 7500, color: 0xff69b4, blowThreshold: 25, blowMaxDuration: 100 };
        const STATE = { INTRO: -1, IDLE: 0, COUNTDOWN: 1, CAKE: 2, BLOWING: 3, CELEBRATION: 4, SCATTERED: 5 };
        
        let currentState = STATE.INTRO; // ä»å¯åŠ¨é¡µå¼€å§‹
        let isCakeScattered = false; // è›‹ç³•æ˜¯å¦å·²æ•£å¼€
        let starParticles = []; // æ˜Ÿæ˜Ÿç²’å­æ•°æ®
        let currentPhotoIndex = -1; // å½“å‰æ˜¾ç¤ºçš„ç…§ç‰‡ç´¢å¼•
        let lastLeftHandState = null; // ä¸Šæ¬¡å·¦æ‰‹çŠ¶æ€
        let lastRightHandState = null; // ä¸Šæ¬¡å³æ‰‹çŠ¶æ€
        let fireworks = []; // çƒŸèŠ±ç²’å­æ•°ç»„
        let fireworkTimer = null; // çƒŸèŠ±å®šæ—¶å™¨
        
        // ç…§ç‰‡é…ç½®ï¼ˆå¯ä»¥æ ¹æ®éœ€è¦æ·»åŠ æ›´å¤šç…§ç‰‡ï¼‰
        // æ³¨æ„ï¼šéœ€è¦å‡†å¤‡5å¼ ä¸åŒçš„ç…§ç‰‡ï¼Œæˆ–è€…ä½¿ç”¨åŒä¸€å¼ ç…§ç‰‡çš„ä¸åŒç‰ˆæœ¬
        const PHOTOS = [
            { src: './src/1.jpg', position: 'top-left' },      // å·¦ä¸Š
            { src: './src/1.jpg', position: 'top-right' },     // å³ä¸Š
            { src: './src/1.jpg', position: 'bottom-left' },  // å·¦ä¸‹
            { src: './src/1.jpg', position: 'bottom-right' }, // å³ä¸‹
            { src: './src/1.jpg', position: 'center' }         // ä¸­é—´
        ];
        let interactionMode = 0; 
        
        let particlesData = [];
        let scene, camera, renderer, particleSystem;
        let time = 0;
        let shapeCache = {}; 
        let blowProgress = 0;
        let isSpacePressed = false; 
        let isTouching = false; 
        
        let rotationVelocity = 0;
        let isDragging = false;
        let previousMouseX = 0;
        let lastHandX = 0;
        let autoRotateSpeed = 0.005;

        // --- è‡ªåŠ¨å€’æ•°å˜é‡ ---
        let autoEntryTimer = null;
        let autoEntrySeconds = 10;
        
        let audioContext, analyser;
        const bgm = document.getElementById('bgm');

        const ui = {
            startOverlay: document.getElementById('start-overlay'),
            uiLayer: document.getElementById('ui-layer'),
            statusText: document.getElementById('status-text'),
            statusDot: document.getElementById('status-dot'),
            mainText: document.getElementById('instruction-text'),
            subText: document.getElementById('sub-instruction'),
            handIcon: document.getElementById('hand-icon'),
            blowMeter: document.getElementById('blow-meter-container'),
            blowBar: document.getElementById('blow-meter-bar'),
            blowHint: document.getElementById('blow-hint'),
            surpriseLayer: document.getElementById('surprise-layer'),
            revealBtn: document.getElementById('reveal-btn'),
            floatingGiftBtn: document.getElementById('floating-gift-btn'),
            cardContainer: document.getElementById('flip-card-container'), 
            nextBtn: document.getElementById('next-surprise-btn'),
            closeBtn: document.getElementById('close-card-btn'),
            settingsPanel: document.getElementById('settings-panel'),
            settingsToggle: document.getElementById('settings-toggle'),
            topBanner: document.getElementById('top-banner'),
            startBtn: document.getElementById('start-btn'),
            loadingText: document.getElementById('loading-text'),
            camStatusDot: document.getElementById('cam-status-dot'),
            camStatusText: document.getElementById('cam-status-text'),
            // å¡ç‰‡ç›¸å…³ UI
            page1: document.getElementById('card-page-1'),
            page2: document.getElementById('card-page-2'),
            toPage2Btn: document.getElementById('to-page-2-btn'),
            textContainer1: document.getElementById('typewriter-text-1'),
            textContainer2: document.getElementById('typewriter-text-2'),
            // è‡ªåŠ¨å€’æ•°æ–‡æœ¬
            autoCountdownText: document.getElementById('auto-countdown-text'),
            // ç…§ç‰‡ç›¸å…³ UI
            photoLayer: document.getElementById('photo-layer'),
            displayPhoto: document.getElementById('display-photo')
        };

        // ç«‹å³åˆå§‹åŒ– Three.js
        initThree();

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;
            renderer = new THREE.WebGLRenderer({ antialias: !IS_MOBILE, alpha: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            preloadShapes();
            createParticles();
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            const onStart = (x) => {
                if(interactionMode === 1) {
                    isDragging = true;
                    previousMouseX = x;
                    rotationVelocity = 0; 
                }
            };
            const onMove = (x) => {
                if(isDragging && interactionMode === 1) {
                    const delta = x - previousMouseX;
                    const sensitivity = IS_MOBILE ? 0.015 : 0.008; 
                    rotationVelocity = delta * sensitivity;
                    particleSystem.rotation.y += rotationVelocity;
                    previousMouseX = x;
                }
            };
            const onEnd = () => { isDragging = false; };

            container.addEventListener('mousedown', (e) => onStart(e.clientX));
            window.addEventListener('mousemove', (e) => onMove(e.clientX));
            window.addEventListener('mouseup', onEnd);

            container.addEventListener('touchstart', (e) => onStart(e.touches[0].clientX), {passive: false});
            window.addEventListener('touchmove', (e) => {
                if(isDragging) e.preventDefault(); 
                onMove(e.touches[0].clientX);
            }, {passive: false});
            window.addEventListener('touchend', onEnd);
            
            render();
        }

        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(VISUAL_CONFIG.particleCount * 3);
            const colors = new Float32Array(VISUAL_CONFIG.particleCount * 3);
            const sizes = new Float32Array(VISUAL_CONFIG.particleCount);
            particlesData = [];
            const c = new THREE.Color(VISUAL_CONFIG.color);

            for (let i = 0; i < VISUAL_CONFIG.particleCount; i++) {
                const x = (Math.random() - 0.5) * 300;
                const y = (Math.random() - 0.5) * 300;
                const z = (Math.random() - 0.5) * 200;
                positions[i * 3] = x; positions[i * 3 + 1] = y; positions[i * 3 + 2] = z;
                colors[i * 3] = c.r; colors[i * 3 + 1] = c.g; colors[i * 3 + 2] = c.b;
                sizes[i] = Math.random() * 2;
                particlesData.push({
                    current: new THREE.Vector3(x, y, z),
                    target: new THREE.Vector3(x, y, z),
                    baseTarget: new THREE.Vector3(x, y, z),
                    velocity: new THREE.Vector3(0, 0, 0),
                    type: 'bg', layer: null, targetColor: c.clone(),
                    noiseOffset: Math.random() * 100,
                    angle: Math.random() * Math.PI * 2, 
                    radius: 20 + Math.random() * 40,
                    orbitSpeed: (Math.random() - 0.5) * 0.02,
                    twinkle: Math.random() * Math.PI * 2, // æ˜Ÿæ˜Ÿé—ªçƒç›¸ä½
                    size: Math.random() * 2 // æ˜Ÿæ˜Ÿå¤§å°
                });
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            const material = new THREE.PointsMaterial({ size: 1.2, vertexColors: true, map: getCircleTexture(), transparent: true, opacity: 0.8, depthWrite: false, blending: THREE.AdditiveBlending });
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        function getCircleTexture() {
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const ctx=c.getContext('2d');
            const g=ctx.createRadialGradient(32,32,0,32,32,32);
            g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(255,255,255,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }

        function getShapePoints(type, text) {
            const points = [];
            if (type === 'text') {
                const c = document.createElement('canvas'); c.width=250; c.height=250;
                const ctx=c.getContext('2d');
                ctx.font = 'bold 120px Arial';
                ctx.fillStyle = 'white'; ctx.textAlign='center'; ctx.textBaseline='middle';
                ctx.fillText(text, 125, 125);
                const data = ctx.getImageData(0,0,250,250).data;
                const step = 2;
                for(let y=0; y<250; y+=step) {
                    for(let x=0; x<250; x+=step) {
                        if(data[(y*250+x)*4+3]>128) {
                            points.push({ vec: new THREE.Vector3((x-125)/3.5, -(y-125)/3.5, 0).multiplyScalar(2), type: 'text', color: new THREE.Color(0xffffff) });
                        }
                    }
                }
            } else if (type === 'cake') {
                const layers = [{y: -16, r: 18, h: 10, type: 'bottom'}, {y: -6,  r: 13, h: 8,  type: 'top'}];
                layers.forEach(l => {
                    for(let i=0; i<(IS_MOBILE?800:1500); i++) {
                        const theta = Math.random() * Math.PI * 2;
                        const r = l.r * (0.95 + Math.random()*0.05); 
                        const h = Math.random() * l.h;
                        points.push({ vec: new THREE.Vector3(r*Math.cos(theta), l.y+h, r*Math.sin(theta)), type: 'cake', layer: l.type });
                    }
                    for(let i=0; i<500; i++) {
                        const theta = Math.random() * Math.PI * 2;
                        const r = Math.random() * l.r;
                        points.push({ vec: new THREE.Vector3(r*Math.cos(theta), l.y+l.h, r*Math.sin(theta)), type: 'cake', layer: 'cream' });
                    }
                    for(let i=0; i<100; i++) {
                        const theta = Math.random() * Math.PI * 2;
                        const r = l.r + 0.2;
                        const h = Math.random() * l.h;
                        const sprinkleColor = new THREE.Color().setHSL(Math.random(), 1, 0.6);
                        points.push({
                            vec: new THREE.Vector3(r*Math.cos(theta), l.y+h, r*Math.sin(theta)),
                            type: 'cake', color: sprinkleColor
                        });
                    }
                });
                const candleY = layers[1].y + layers[1].h;
                for(let i=0; i<300; i++) {
                    const h = Math.random() * 12;
                    const r = Math.random() * 0.8;
                    const theta = Math.random() * Math.PI * 2;
                    let col = (Math.sin(h*1.5 + theta)>0) ? new THREE.Color(0xFF0000) : new THREE.Color(0xFFFFFF);
                    points.push({ vec: new THREE.Vector3(r*Math.cos(theta), candleY+h, r*Math.sin(theta)), type: 'candle', color: col });
                }
                const flameY = candleY + 12;
                for(let i=0; i<400; i++) {
                    const u = Math.random();
                    const h = u * 7;
                    const r = (1-u) * 2.0 * Math.random();
                    const theta = Math.random() * Math.PI * 2;
                    let col = new THREE.Color(0xFFA500);
                    if(u<0.2) col.setHex(0x0000FF); else if(u>0.7) col.setHex(0xFF4500);
                    points.push({ vec: new THREE.Vector3(r*Math.cos(theta), flameY+h, r*Math.sin(theta)), type: 'flame', color: col });
                }
            }
            return points;
        }

        function preloadShapes() {
            setTimeout(() => {
                shapeCache['3'] = getShapePoints('text', '3');
                shapeCache['2'] = getShapePoints('text', '2');
                shapeCache['1'] = getShapePoints('text', '1');
                shapeCache['cake'] = getShapePoints('cake');
                ui.loadingText.style.display = 'none';
            }, 100);
        }

        // --- æ‰‹åŠ¿è¯†åˆ«å‡½æ•° ---
        // æ£€æµ‹æ‰‹æŒ‡æ˜¯å¦å¼ å¼€ï¼ˆé€šè¿‡è®¡ç®—æŒ‡å°–åˆ°æ‰‹æŒçš„è·ç¦»ï¼‰
        function isHandOpen(landmarks) {
            const wrist = landmarks[0];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            
            // è®¡ç®—å„æŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦»
            const distances = [
                Math.sqrt(Math.pow(thumbTip.x - wrist.x, 2) + Math.pow(thumbTip.y - wrist.y, 2)),
                Math.sqrt(Math.pow(indexTip.x - wrist.x, 2) + Math.pow(indexTip.y - wrist.y, 2)),
                Math.sqrt(Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2)),
                Math.sqrt(Math.pow(ringTip.x - wrist.x, 2) + Math.pow(ringTip.y - wrist.y, 2)),
                Math.sqrt(Math.pow(pinkyTip.x - wrist.x, 2) + Math.pow(pinkyTip.y - wrist.y, 2))
            ];
            
            // æ”¹è¿›ç®—æ³•ï¼šæ£€æŸ¥æ¯ä¸ªæ‰‹æŒ‡æ˜¯å¦å¼ å¼€
            // å¦‚æœè‡³å°‘4ä¸ªæ‰‹æŒ‡éƒ½å¼ å¼€ï¼ˆè·ç¦»è¾ƒå¤§ï¼‰ï¼Œè¿”å›true
            const openFingers = distances.filter(d => d > 0.12).length; // é™ä½é˜ˆå€¼åˆ°0.12
            const avgDistance = distances.reduce((a, b) => a + b, 0) / distances.length;
            
            // åŒé‡åˆ¤æ–­ï¼šå¹³å‡è·ç¦»è¾ƒå¤§ ä¸” è‡³å°‘4ä¸ªæ‰‹æŒ‡å¼ å¼€
            return avgDistance > 0.12 && openFingers >= 4;
        }

        // æ£€æµ‹æ˜¯å¦æ¡æ‹³ï¼ˆæ‰‹æŒ‡éƒ½æ”¶æ‹¢ï¼‰
        function isHandFist(landmarks) {
            const wrist = landmarks[0];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            
            // è®¡ç®—å„æŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦»
            const distances = [
                Math.sqrt(Math.pow(thumbTip.x - wrist.x, 2) + Math.pow(thumbTip.y - wrist.y, 2)),
                Math.sqrt(Math.pow(indexTip.x - wrist.x, 2) + Math.pow(indexTip.y - wrist.y, 2)),
                Math.sqrt(Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2)),
                Math.sqrt(Math.pow(ringTip.x - wrist.x, 2) + Math.pow(ringTip.y - wrist.y, 2)),
                Math.sqrt(Math.pow(pinkyTip.x - wrist.x, 2) + Math.pow(pinkyTip.y - wrist.y, 2))
            ];
            
            // å¦‚æœæ‰€æœ‰æ‰‹æŒ‡éƒ½æ”¶æ‹¢ï¼ˆè·ç¦»è¾ƒå°ï¼‰ï¼Œè¿”å›true
            const avgDistance = distances.reduce((a, b) => a + b, 0) / distances.length;
            return avgDistance < 0.08; // é˜ˆå€¼å¯è°ƒæ•´
        }

        // æ ¹æ®æ‰‹çš„ä½ç½®ç¡®å®šç…§ç‰‡ç´¢å¼•
        function getPhotoIndexByPosition(landmarks) {
            const palm = landmarks[9]; // æ‰‹æŒä¸­å¿ƒ
            const x = palm.x; // 0-1 èŒƒå›´ï¼Œ0åœ¨å·¦è¾¹ï¼Œ1åœ¨å³è¾¹
            const y = palm.y; // 0-1 èŒƒå›´ï¼Œ0åœ¨ä¸Šè¾¹ï¼Œ1åœ¨ä¸‹è¾¹
            
            // å°†å±å¹•åˆ†ä¸º5ä¸ªåŒºåŸŸï¼ˆæ ¹æ®å½’ä¸€åŒ–åæ ‡ï¼‰
            // MediaPipe çš„åæ ‡ç³»ç»Ÿï¼šx=0 åœ¨å·¦è¾¹ï¼Œx=1 åœ¨å³è¾¹ï¼›y=0 åœ¨ä¸Šè¾¹ï¼Œy=1 åœ¨ä¸‹è¾¹
            if (x < 0.4 && y < 0.5) return 0; // å·¦ä¸Š
            if (x >= 0.6 && y < 0.5) return 1; // å³ä¸Š
            if (x < 0.4 && y >= 0.5) return 2; // å·¦ä¸‹
            if (x >= 0.6 && y >= 0.5) return 3; // å³ä¸‹
            return 4; // ä¸­é—´åŒºåŸŸ
        }

        // æ•£å¼€è›‹ç³•å¹¶æ·»åŠ æ˜Ÿæ˜Ÿ
        function scatterCakeAndAddStars() {
            if (isCakeScattered) return;
            isCakeScattered = true;
            currentState = STATE.SCATTERED;
            
            log('è›‹ç³•æ•£å¼€ï¼Œæ·»åŠ æ˜Ÿæ˜Ÿ');
            
            // æ•£å¼€è›‹ç³•ç²’å­
            particlesData.forEach((p, i) => {
                if (p.type === 'cake' || p.type === 'candle' || p.type === 'flame') {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 50 + Math.random() * 100;
                    const height = (Math.random() - 0.5) * 80;
                    p.target.set(
                        Math.cos(angle) * radius,
                        p.current.y + height,
                        Math.sin(angle) * radius
                    );
                    p.velocity.add(new THREE.Vector3(
                        (Math.random() - 0.5) * 5,
                        Math.random() * 3,
                        (Math.random() - 0.5) * 5
                    ));
                }
            });
            
            // æ·»åŠ ç²‰è‰²äº®æ˜Ÿæ˜Ÿ
            const starCount = Math.min(200, particlesData.length);
            for (let i = 0; i < starCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 20 + Math.random() * 40;
                const height = (Math.random() - 0.5) * 60;
                
                // ä½¿ç”¨ç°æœ‰çš„ç²’å­æ•°æ®
                const p = particlesData[i];
                p.current.set(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                p.target.copy(p.current);
                p.type = 'star';
                p.targetColor = new THREE.Color(0xff69b4); // ç²‰è‰²
                p.size = 3 + Math.random() * 2;
                p.twinkle = Math.random() * Math.PI * 2;
                p.velocity.set(0, 0, 0);
                
                starParticles.push({
                    index: i,
                    angle: angle,
                    radius: radius,
                    height: height
                });
            }
        }

        // å›å½’è›‹ç³•å½¢çŠ¶
        function returnToCake() {
            if (!isCakeScattered) return;
            isCakeScattered = false;
            currentState = STATE.CAKE;
            starParticles = [];
            
            log('å›å½’è›‹ç³•å½¢çŠ¶');
            transitionTo('cake');
            
            // éšè—ç…§ç‰‡
            hidePhoto();
        }

        // æ˜¾ç¤ºç…§ç‰‡
        function showPhoto(photoIndex, x, y) {
            if (photoIndex < 0 || photoIndex >= PHOTOS.length) return;
            
            const photo = PHOTOS[photoIndex];
            
            // å¦‚æœç…§ç‰‡ç´¢å¼•æ”¹å˜ï¼Œæ›´æ–°ç…§ç‰‡æº
            if (currentPhotoIndex !== photoIndex) {
                ui.displayPhoto.src = photo.src;
            }
            
            // å°†å½’ä¸€åŒ–åæ ‡è½¬æ¢ä¸ºå±å¹•åæ ‡
            const screenX = x * window.innerWidth;
            const screenY = y * window.innerHeight;
            
            // ç¡®ä¿ç…§ç‰‡åœ¨å±å¹•å†…
            const photoWidth = 300;
            const photoHeight = 300;
            const left = Math.max(10, Math.min(screenX - photoWidth / 2, window.innerWidth - photoWidth - 10));
            const top = Math.max(10, Math.min(screenY - photoHeight / 2, window.innerHeight - photoHeight - 10));
            
            ui.displayPhoto.style.left = left + 'px';
            ui.displayPhoto.style.top = top + 'px';
            ui.photoLayer.classList.remove('hidden');
            
            setTimeout(() => {
                ui.displayPhoto.style.opacity = '1';
                ui.displayPhoto.style.transform = 'scale(1)';
            }, 10);
            
            currentPhotoIndex = photoIndex;
            log(`æ˜¾ç¤ºç…§ç‰‡ ${photoIndex} (${photo.position}) åœ¨å±å¹•ä½ç½® (${Math.round(left)}, ${Math.round(top)})`);
        }

        // éšè—ç…§ç‰‡
        function hidePhoto() {
            ui.displayPhoto.style.opacity = '0';
            ui.displayPhoto.style.transform = 'scale(0.8)';
            setTimeout(() => {
                ui.photoLayer.classList.add('hidden');
                currentPhotoIndex = -1;
            }, 300);
            log('éšè—ç…§ç‰‡');
        }

        // åˆ›å»ºçƒŸèŠ±ç²’å­
        function createFireworkParticle(x, y, z, color, velocity) {
            return {
                position: new THREE.Vector3(x, y, z),
                velocity: velocity.clone(),
                color: color.clone(),
                life: 1.0, // ç”Ÿå‘½å‘¨æœŸ 0-1
                size: 2.5 + Math.random() * 3.5,
                gravity: 0.015,
                fade: 0.015 + Math.random() * 0.015,
                type: 'firework' // æ ‡è®°ä¸ºçƒŸèŠ±ç²’å­
            };
        }

        // åœ¨æŒ‡å®šä½ç½®é‡Šæ”¾çƒŸèŠ±
        function launchFirework(centerX, centerY, centerZ, color) {
            const particleCount = 60 + Math.floor(Math.random() * 40);
            const colors = color ? [color] : [
                new THREE.Color(0xff0000), // çº¢
                new THREE.Color(0x00ff00), // ç»¿
                new THREE.Color(0x0000ff), // è“
                new THREE.Color(0xffff00), // é»„
                new THREE.Color(0xff00ff), // ç´«
                new THREE.Color(0x00ffff), // é’
                new THREE.Color(0xff69b4), // ç²‰
                new THREE.Color(0xffa500), // æ©™
                new THREE.Color(0xffffff)  // ç™½
            ];
            
            // éšæœºé€‰æ‹©2-3ç§é¢œè‰²ä½œä¸ºè¿™ä¸ªçƒŸèŠ±çš„é…è‰²
            const selectedColors = [];
            const colorCount = 2 + Math.floor(Math.random() * 2);
            for (let i = 0; i < colorCount; i++) {
                selectedColors.push(colors[Math.floor(Math.random() * colors.length)]);
            }
            
            for (let i = 0; i < particleCount; i++) {
                // ä½¿ç”¨çƒé¢åˆ†å¸ƒï¼Œè®©çƒŸèŠ±æ›´ç«‹ä½“
                const theta = Math.random() * Math.PI * 2; // æ°´å¹³è§’åº¦
                const phi = Math.acos(2 * Math.random() - 1); // å‚ç›´è§’åº¦
                const speed = 0.8 + Math.random() * 1.2;
                
                const velocity = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(theta) * speed,
                    Math.sin(phi) * Math.sin(theta) * speed,
                    Math.cos(phi) * speed
                );
                
                const particleColor = selectedColors[Math.floor(Math.random() * selectedColors.length)];
                const particle = createFireworkParticle(
                    centerX,
                    centerY,
                    centerZ,
                    particleColor,
                    velocity
                );
                
                fireworks.push(particle);
            }
        }

        // åœ¨å¡ç‰‡å‘¨å›´é‡Šæ”¾çƒŸèŠ±
        function launchFireworksAroundCard() {
            // è·å–å¡ç‰‡åœ¨å±å¹•ä¸Šçš„ä½ç½®ï¼ˆè½¬æ¢ä¸º3Dåæ ‡ï¼‰
            const cardElement = ui.cardContainer;
            if (!cardElement || cardElement.classList.contains('hidden')) return;
            
            const rect = cardElement.getBoundingClientRect();
            const centerX = (rect.left + rect.width / 2) / window.innerWidth;
            const centerY = (rect.top + rect.height / 2) / window.innerHeight;
            
            // è½¬æ¢ä¸º3Dç©ºé—´åæ ‡ï¼ˆå‡è®¾å¡ç‰‡åœ¨z=0é™„è¿‘ï¼‰
            // ä½¿ç”¨ç›¸æœºçš„è§†é‡èŒƒå›´æ¥è½¬æ¢
            const worldX = (centerX - 0.5) * 80;
            const worldY = (0.5 - centerY) * 60; // ç¿»è½¬Yè½´
            const worldZ = -20; // ç¨å¾®é å‰ä¸€ç‚¹
            
            // åœ¨å¡ç‰‡å‘¨å›´12ä¸ªæ–¹å‘é‡Šæ”¾çƒŸèŠ±ï¼Œå½¢æˆåœ†å½¢åŒ…å›´
            const fireworkCount = 12;
            const radius = 25;
            
            for (let i = 0; i < fireworkCount; i++) {
                const angle = (Math.PI * 2 * i) / fireworkCount;
                const offsetX = Math.cos(angle) * radius;
                const offsetY = Math.sin(angle) * radius;
                const offsetZ = (Math.random() - 0.5) * 10;
                
                setTimeout(() => {
                    launchFirework(
                        worldX + offsetX,
                        worldY + offsetY,
                        worldZ + offsetZ,
                        null
                    );
                }, i * 80); // é”™å¼€æ—¶é—´ï¼Œå½¢æˆè¿ç»­æ—‹è½¬æ•ˆæœ
            }
            
            log('åœ¨å¡ç‰‡å‘¨å›´é‡Šæ”¾çƒŸèŠ±');
        }

        // æ›´æ–°çƒŸèŠ±ç²’å­
        function updateFireworks() {
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const fw = fireworks[i];
                
                // æ›´æ–°ä½ç½®
                fw.position.add(fw.velocity);
                fw.velocity.y -= fw.gravity; // é‡åŠ›
                fw.velocity.multiplyScalar(0.98); // é˜»åŠ›
                
                // æ›´æ–°ç”Ÿå‘½å‘¨æœŸ
                fw.life -= fw.fade;
                
                // ç§»é™¤å·²æ¶ˆå¤±çš„ç²’å­
                if (fw.life <= 0 || fw.position.y < -50) {
                    fireworks.splice(i, 1);
                }
            }
        }

        // æ¸²æŸ“çƒŸèŠ±åˆ°ç²’å­ç³»ç»Ÿ
        function renderFireworks() {
            if (fireworks.length === 0) return;
            
            // ä½¿ç”¨ç°æœ‰çš„ç²’å­ç³»ç»Ÿæ¥æ˜¾ç¤ºçƒŸèŠ±
            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.color.array;
            const sizes = particleSystem.geometry.attributes.size.array;
            
            // æ‰¾åˆ°å¯ç”¨çš„ç²’å­æ§½ä½ï¼ˆä¼˜å…ˆä½¿ç”¨èƒŒæ™¯ç²’å­ï¼Œå¦‚æœä¸å¤Ÿå°±ç”¨å…¶ä»–ç±»å‹çš„ç²’å­ï¼‰
            let slotIndex = 0;
            let usedSlots = new Set();
            
            for (let i = 0; i < fireworks.length && slotIndex < VISUAL_CONFIG.particleCount; i++) {
                const fw = fireworks[i];
                
                // ä¼˜å…ˆæ‰¾èƒŒæ™¯ç²’å­
                let found = false;
                for (let j = 0; j < particlesData.length; j++) {
                    if (!usedSlots.has(j) && (particlesData[j].type === 'bg' || particlesData[j].type === 'firework')) {
                        slotIndex = j;
                        found = true;
                        break;
                    }
                }
                
                // å¦‚æœæ²¡æ‰¾åˆ°èƒŒæ™¯ç²’å­ï¼Œæ‰¾ä»»ä½•å¯ç”¨çš„ç²’å­
                if (!found) {
                    for (let j = 0; j < particlesData.length; j++) {
                        if (!usedSlots.has(j) && particlesData[j].type !== 'cake' && particlesData[j].type !== 'candle' && particlesData[j].type !== 'flame') {
                            slotIndex = j;
                            found = true;
                            break;
                        }
                    }
                }
                
                if (found && slotIndex < particlesData.length) {
                    const p = particlesData[slotIndex];
                    usedSlots.add(slotIndex);
                    
                    // ä¸´æ—¶æ ‡è®°ä¸ºçƒŸèŠ±ç²’å­
                    const originalType = p.type;
                    p.type = 'firework';
                    
                    // æ›´æ–°ç²’å­ä½ç½®å’Œé¢œè‰²
                    p.current.copy(fw.position);
                    p.target.copy(fw.position);
                    
                    // æ ¹æ®ç”Ÿå‘½å‘¨æœŸè°ƒæ•´é¢œè‰²å’Œå¤§å°
                    const alpha = Math.max(0, fw.life);
                    p.targetColor.copy(fw.color);
                    p.targetColor.multiplyScalar(alpha * 1.5); // ç¨å¾®äº®ä¸€ç‚¹
                    
                    // æ›´æ–°ç¼“å†²åŒº
                    positions[slotIndex * 3] = fw.position.x;
                    positions[slotIndex * 3 + 1] = fw.position.y;
                    positions[slotIndex * 3 + 2] = fw.position.z;
                    
                    colors[slotIndex * 3] = fw.color.r * alpha;
                    colors[slotIndex * 3 + 1] = fw.color.g * alpha;
                    colors[slotIndex * 3 + 2] = fw.color.b * alpha;
                    
                    sizes[slotIndex] = fw.size * alpha;
                }
            }
            
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;
            particleSystem.geometry.attributes.size.needsUpdate = true;
        }

        function transitionTo(key) {
            const targets = shapeCache[key] || [];
            particlesData.forEach((p, i) => {
                if (i < targets.length) {
                    p.baseTarget.copy(targets[i].vec);
                    p.target.copy(targets[i].vec);
                    p.type = targets[i].type;
                    p.layer = targets[i].layer;
                    if(targets[i].color) {
                        p.targetColor = targets[i].color.clone();
                    } else {
                        p.targetColor = new THREE.Color(0xffffff); 
                    }
                    const force = 3;
                    p.current.add(new THREE.Vector3((Math.random()-0.5)*force, (Math.random()-0.5)*force, (Math.random()-0.5)*force));
                } else {
                    const angle = Math.random() * Math.PI * 2;
                    const r = 40 + Math.random() * 40;
                    p.baseTarget.set(r*Math.cos(angle), (Math.random()-0.5)*60, r*Math.sin(angle));
                    p.target.copy(p.baseTarget);
                    p.type = 'bg';
                    p.layer = null;
                    p.targetColor = new THREE.Color(0x222222);
                }
            });
        }

        function updateParticles() {
            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.color.array;
            const sizes = particleSystem.geometry.attributes.size.array;
            time += 0.02;
            const blowInfluence = blowProgress / 100;
            
            // æ›´æ–°çƒŸèŠ±
            updateFireworks();

            for (let i = 0; i < VISUAL_CONFIG.particleCount; i++) {
                const p = particlesData[i];
                let target = p.target.clone();

                if (p.type === 'cake') {
                    if (p.layer === 'bottom') p.targetColor.set(CAKE_THEME.bottom);
                    else if (p.layer === 'top') p.targetColor.set(CAKE_THEME.top);
                    else if (p.layer === 'cream') p.targetColor.set(CAKE_THEME.cream);
                }

                if (currentState === STATE.INTRO) {
                    const angle = p.angle + time * 0.05;
                    const r = p.radius + Math.sin(time * 0.5 + i * 0.01) * 10;
                    target.x = Math.cos(angle) * r * 3;
                    target.z = Math.sin(angle) * r * 3;
                    target.y = p.baseTarget.y + Math.sin(time * 0.5 + target.x * 0.05) * 20; 
                    const hue = 0.8 + (Math.sin(time * 0.1 + target.x * 0.01) * 0.1); 
                    p.targetColor.setHSL(hue, 0.7, 0.6);
                }
                else if (currentState === STATE.CELEBRATION && p.type === 'bg') {
                    const angle = p.angle + time * 0.1 + p.orbitSpeed;
                    const r = p.radius + Math.sin(time + i) * 5;
                    target.x = Math.cos(angle) * r;
                    target.z = Math.sin(angle) * r;
                    target.y = p.baseTarget.y + Math.sin(time + p.noiseOffset) * 2;
                    const hue = 0.9 + (Math.sin(time + i * 0.01) * 0.05); 
                    p.targetColor.setHSL(hue, 0.8, 0.6);
                } 
                else if (currentState === STATE.IDLE) {
                    const angle = p.angle + time * 0.1;
                    const r = p.radius + Math.sin(time + i * 0.01)*2;
                    target.x = Math.cos(angle) * r;
                    target.z = Math.sin(angle) * r;
                    target.y = p.baseTarget.y + Math.sin(time + target.x * 0.05) * 5; 
                    p.targetColor.set(0x333333); 
                }
                else if (currentState === STATE.SCATTERED && p.type === 'star') {
                    // æ˜Ÿæ˜Ÿé—ªçƒæ•ˆæœ
                    const twinkle = Math.sin(time * 3 + (p.twinkle || 0)) * 0.3 + 0.7;
                    p.targetColor.setRGB(1, 0.41, 0.71); // ç²‰è‰² #ff69b4
                    p.targetColor.multiplyScalar(twinkle * 1.5); // æ›´äº®
                    
                    // æ˜Ÿæ˜Ÿè½»å¾®æµ®åŠ¨
                    const floatX = Math.cos(time * 1.5 + i * 0.1) * 1;
                    const floatY = Math.sin(time * 2 + i * 0.1) * 2;
                    const floatZ = Math.sin(time * 1.8 + i * 0.1) * 1;
                    target.x += floatX;
                    target.y += floatY;
                    target.z += floatZ;
                    
                    sizes[i] = (p.size || 3) * (0.8 + twinkle * 0.4);
                }

                if (p.type === 'flame') {
                    const noise = Math.sin(time * 6 + p.noiseOffset) * 0.6;
                    target.x += noise;
                    if (blowInfluence > 0.1 || currentState === STATE.CELEBRATION) {
                        let lift = blowInfluence * 25;
                        if(currentState === STATE.CELEBRATION) lift = 60;
                        target.y += lift;
                        target.x += (Math.random()-0.5) * lift * 0.8;
                        p.targetColor.lerp(new THREE.Color(0xdddddd), 0.1); 
                    }
                }

                p.current.lerp(target, 0.08);

                positions[i*3] = p.current.x;
                positions[i*3+1] = p.current.y;
                positions[i*3+2] = p.current.z;
                
                colors[i*3] += (p.targetColor.r - colors[i*3]) * 0.1;
                colors[i*3+1] += (p.targetColor.g - colors[i*3+1]) * 0.1;
                colors[i*3+2] += (p.targetColor.b - colors[i*3+2]) * 0.1;

                if (p.type === 'flame' && (blowInfluence > 0.1 || currentState === STATE.CELEBRATION)) {
                    sizes[i] = Math.max(0, 1.5 * (1 - blowInfluence)); 
                    if(currentState === STATE.CELEBRATION) sizes[i] *= 0.9;
                } else {
                    sizes[i] = 1.2 + Math.sin(time + i) * 0.3;
                }
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;
            particleSystem.geometry.attributes.size.needsUpdate = true;
            
            // æ¸²æŸ“çƒŸèŠ±
            renderFireworks();
            
            if (interactionMode === 1) {
                if (!isDragging) {
                    rotationVelocity *= 0.96; 
                    particleSystem.rotation.y += rotationVelocity + autoRotateSpeed;
                }
            } else if (currentState !== STATE.IDLE && currentState !== STATE.INTRO) {
                particleSystem.rotation.y = Math.sin(time * 0.15) * 0.15;
            } else {
                particleSystem.rotation.y = 0;
            }
        }

        /* --- ä¸šåŠ¡é€»è¾‘ --- */
        let transitionLock = false;

        function startSequence() {
            if (currentState !== STATE.IDLE || transitionLock) return;
                        
            // æ¸…é™¤è‡ªåŠ¨å€’æ•°è®¡æ—¶å™¨
            if (autoEntryTimer) {
                clearInterval(autoEntryTimer);
                autoEntryTimer = null;
            }
            ui.autoCountdownText.classList.add('hidden');

            log('æ£€æµ‹åˆ°æ‰‹åŠ¿ï¼Œå¼€å§‹å€’è®¡æ—¶åºåˆ—');
            transitionLock = true;
            currentState = STATE.COUNTDOWN;
            ui.statusText.innerText = "GESTURE DETECTED";
            ui.statusText.className = "text-xs md:text-sm text-green-400 font-bold tracking-wider";
            ui.statusDot.className = "inline-block w-2 h-2 rounded-full bg-green-500 mr-2 shadow-[0_0_8px_#0f0]";
            ui.handIcon.style.display = 'none';
            let count = 3;
            ui.mainText.innerText = "";
            ui.subText.innerText = "";
            transitionTo('3');
            const timer = setInterval(() => {
                count--;
                if (count > 0) {
                    transitionTo(count.toString());
                } else {
                    clearInterval(timer);
                    showCake();
                }
            }, 1200);
        }

        function showCake() {
            log('å±•ç¤ºè›‹ç³•ï¼Œå¼€å¯æ‰‹åŠ¿æ§åˆ¶');
            currentState = STATE.CAKE; // å…ˆè®¾ç½®ä¸ºCAKEçŠ¶æ€ï¼Œå…è®¸æ‰‹åŠ¿è¯†åˆ«
            transitionTo('cake');
            ui.settingsPanel.style.display = 'flex';
            ui.mainText.innerText = "";
            ui.subText.innerText = "";
            ui.topBanner.classList.remove('hidden'); 
            // æ£€æµ‹æ˜¯å¦åœ¨ file:// åè®®ä¸‹
            if (window.location.protocol === 'file:') {
                ui.statusText.innerText = "CAKE READY - PRESS S TO SCATTER";
            } else {
                ui.statusText.innerText = "CAKE READY - GESTURE CONTROL";
            }
            ui.blowMeter.style.opacity = '0'; // æš‚æ—¶éšè—å¹æ°”æ¡
            ui.blowHint.style.opacity = '0';
            
            // å»¶è¿Ÿå¼€å¯å¹æ°”æ£€æµ‹ï¼Œå…ˆè®©ç”¨æˆ·å¯ä»¥ç”¨æ‰‹åŠ¿
            setTimeout(() => {
                if (currentState === STATE.CAKE) {
                    currentState = STATE.BLOWING;
                    if (window.location.protocol === 'file:') {
                        ui.statusText.innerText = "PRESS S TO SCATTER, R TO RESTORE";
                    } else {
                        ui.statusText.innerText = "MIC LISTENING...";
                    }
                    ui.blowMeter.style.opacity = '1';
                    ui.blowHint.style.opacity = '1';
                }
            }, 5000); // 5ç§’åè‡ªåŠ¨å¼€å¯å¹æ°”æ£€æµ‹
        }

        function successCelebration() {
            log('è®¸æ„¿æˆåŠŸï¼æ’­æ”¾åº†ç¥åŠ¨ç”»');
            currentState = STATE.CELEBRATION;
            ui.statusText.innerText = "WISH GRANTED";
            ui.blowMeter.style.opacity = '0';
            ui.blowHint.style.opacity = '0';
            ui.settingsPanel.style.display = 'none';
            
            document.body.classList.add('shake-screen');
            setTimeout(() => document.body.classList.remove('shake-screen'), 500);

            particlesData.forEach(p => {
                if (p.type === 'cake' || p.type === 'candle' || p.type === 'ring') {
                    p.target.y += Math.sin(p.current.x * 0.5) * 0.5; 
                } else if (p.type !== 'flame') {
                    p.type = 'bg'; 
                }
            });

            setTimeout(() => {
                ui.surpriseLayer.classList.remove('hidden');
                ui.surpriseLayer.classList.add('active');
                ui.revealBtn.classList.remove('hidden');
            }, 1500);
        }

        document.getElementById('picker-bottom').addEventListener('input', (e) => CAKE_THEME.bottom = e.target.value);
        document.getElementById('picker-top').addEventListener('input', (e) => CAKE_THEME.top = e.target.value);
        document.getElementById('picker-cream').addEventListener('input', (e) => CAKE_THEME.cream = e.target.value);
        
        ui.settingsToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            const display = ui.settingsPanel.style.display;
            ui.settingsPanel.style.display = (display === 'none' || display === '') ? 'flex' : 'none';
        });

        // ç¬¬ä¸€é¡µç¥ç¦è¯­
        const wishes_part1 = [
            "ç”Ÿæ—¥å¿«ä¹ï¼",
            "",
            "æ„¿ä½ çš„ç”Ÿå‘½å¦‚è¿™ç§‹å¤©çš„æ£®æ—ï¼Œ",
            "ä¸å¿…è¿½é€ç¹ç››ï¼Œ",
            "åªéœ€ä¸€ç‰‡è½å¶çš„ä»å®¹ã€‚",
            "æ¯ä¸€æ¬¡é£˜é›¶éƒ½ä¸æ˜¯ç»ˆç»“ï¼Œ",
            "è€Œæ˜¯ä¸ºäº†æ²‰æ·€ä¸‹æ¥å¹´æ›´ä¸°ç›ˆçš„è‰²å½©ã€‚",
            "æ„¿ä½ çš„æ–°å²ï¼Œæ¸©æ¶¦è€Œé‡‘é»„ã€‚",
            "           â€”â€” é€ç»™æœ€ç‰¹åˆ«çš„ä½  "
        ];

        // ç¬¬äºŒé¡µæ­‰æ„ä¸å¿«é€’
        const wishes_part2 = [
            "Sorryï¼Œæœ‰ç‚¹æƒ­æ„§",
            "å› ä¸ºæˆ‘æ²¡æ‹¿æå‡†æ—¶é—´ï¼Œè¿˜æœ‰å•†å®¶å‘è´§æ—¶é—´æ™šçš„é—®é¢˜ï¼Œæ‰€ä»¥ä»Šå¤©Surpriseå¯èƒ½æ¥ä¸åŠé€åˆ°ä½ æ‰‹ä¸Šã€‚ğŸ˜­",
            "çœŸçš„å¾ˆæŠ±æ­‰",
            "",
            "",
            "å¿«é€’ç¼–å·ï¼š",
            "ä½ å¯ä»¥ç”¨è¿™ä¸ªç¼–å·å»é¡ºä¸°å®˜ç½‘æŸ¥ä¸€ä¸‹ã€‚",
            "å¸Œæœ›ä½ å–œæ¬¢è¿™ä¸ªå°å°çš„Surpriseï¼ğŸ‰ğŸ‚ğŸˆ",
            "è®°å¾—å¼€ç®±ç»™æˆ‘å½•ä¸ªè§†é¢‘æˆ–è€…æ‹ä¸ªç…§å“¦ï¼ğŸ“¸ğŸ˜Š",
            "å› ä¸ºæˆ‘ä¹Ÿè¿˜æ²¡çœ‹è¿‡å‘¢ï¼ğŸ˜†"
        ];

        function typeWriter(textArray, containerId, speed = 50) {
            const container = document.getElementById(containerId);
            container.innerHTML = "";
            let lineIndex = 0;
            let charIndex = 0;

            function type() {
                if (lineIndex < textArray.length) {
                    const currentLine = textArray[lineIndex];
                    if (charIndex < currentLine.length) {
                        container.innerHTML += currentLine.charAt(charIndex);
                        charIndex++;
                        setTimeout(type, speed);
                    } else {
                        container.innerHTML += "<br>";
                        lineIndex++;
                        charIndex = 0;
                        setTimeout(type, 300);
                    }
                    // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
                    container.scrollTop = container.scrollHeight;
                }
            }
            type();
        }

        ui.revealBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            ui.revealBtn.classList.add('hidden');
            ui.cardContainer.classList.remove('hidden');
            // å»¶è¿Ÿä¸€ä¸‹è®©å¡ç‰‡å…ˆæ˜¾ç¤ºï¼Œç„¶åé‡Šæ”¾çƒŸèŠ±
            setTimeout(() => {
                launchFireworksAroundCard();
            }, 300);
        });

        // "What's the surprise" æŒ‰é’® -> ç¿»è½¬åˆ°èƒŒé¢ (ç¬¬ä¸€é¡µ)
        ui.nextBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            ui.cardContainer.classList.add('flipped');
            // æ˜¾ç¤ºç¬¬ä¸€é¡µï¼Œéšè—ç¬¬äºŒé¡µ
            ui.page1.classList.remove('hidden');
            ui.page2.classList.add('hidden');
            setTimeout(() => typeWriter(wishes_part1, 'typewriter-text-1'), 400);
            // ç¿»è½¬æ—¶å†æ¬¡é‡Šæ”¾çƒŸèŠ±
            setTimeout(() => {
                launchFireworksAroundCard();
            }, 500);
        });

        // "è¿˜æœ‰è¯å¯¹ä½ è¯´" æŒ‰é’® -> åˆ‡æ¢åˆ°ç¬¬äºŒé¡µ
        ui.toPage2Btn.addEventListener('click', (e) => {
            e.stopPropagation();
            ui.page1.classList.add('hidden');
            ui.page2.classList.remove('hidden');
            // é‡æ–°è§¦å‘ç¬¬äºŒé¡µçš„æ‰“å­—æœº
            setTimeout(() => typeWriter(wishes_part2, 'typewriter-text-2', 30), 100);
        });

        ui.floatingGiftBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            ui.floatingGiftBtn.classList.add('hidden'); 
            ui.surpriseLayer.classList.remove('hidden'); 
            ui.surpriseLayer.classList.add('active');
            interactionMode = 0;
            ui.cardContainer.classList.remove('hidden');
            ui.cardContainer.classList.remove('flipped');
            // é‡ç½®ä¸ºç¬¬ä¸€é¡µçŠ¶æ€
            ui.page1.classList.remove('hidden');
            ui.page2.classList.add('hidden');
        });

        // "æ”¶èµ·å¡ç‰‡" æŒ‰é’®
        ui.closeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            ui.mainText.innerText = ""; 
            ui.surpriseLayer.classList.remove('active');
            ui.surpriseLayer.classList.add('hidden');    
            ui.floatingGiftBtn.classList.remove('hidden');
            
            interactionMode = 1; 
            transitionTo('cake'); 
            ui.statusText.innerText = "INTERACTIVE MODE: DRAG TO ROTATE";
            ui.typewriter.innerHTML = ""; 
            ui.topBanner.classList.remove('hidden');
        });

        
        // --- è‡ªåŠ¨å€’æ•°åŠŸèƒ½ ---
        function startAutoEntryCountdown() {
            autoEntrySeconds = 15;
            ui.autoCountdownText.classList.remove('hidden');
            ui.autoCountdownText.innerText = `è‹¥æœªæ£€æµ‹åˆ°æ‰‹åŠ¿ï¼Œ${autoEntrySeconds}ç§’åè‡ªåŠ¨å¼€å§‹...`;
            
            // æ¸…é™¤æ—§çš„è®¡æ—¶å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if (autoEntryTimer) clearInterval(autoEntryTimer);

            autoEntryTimer = setInterval(() => {
                autoEntrySeconds--;
                if (autoEntrySeconds > 0) {
                    ui.autoCountdownText.innerText = `è‹¥æœªæ£€æµ‹åˆ°æ‰‹åŠ¿ï¼Œ${autoEntrySeconds}ç§’åè‡ªåŠ¨å¼€å§‹...`;
                } else {
                    clearInterval(autoEntryTimer);
                    autoEntryTimer = null;
                    ui.autoCountdownText.classList.add('hidden');
                    // åªæœ‰åœ¨è¿˜æ˜¯ IDLE çŠ¶æ€æ—¶æ‰è‡ªåŠ¨å¼€å§‹ï¼Œé˜²æ­¢ç”¨æˆ·åˆšå¥½åœ¨æ­¤æ—¶è§¦å‘äº†æ‰‹åŠ¿
                    if (currentState === STATE.IDLE) {
                        log('è‡ªåŠ¨å€’æ•°ç»“æŸï¼Œè§¦å‘å¼€å§‹åºåˆ—');
                        startSequence();
                    }
                }
            }, 1000);
        }

        // æŒ‰é’®ç‚¹å‡»äº‹ä»¶å¤„ç†
        ui.startBtn.addEventListener('click', async function() {
            log('ç‚¹å‡»äº†è¿›å…¥æŒ‰é’®...');
            const btn = this;
            
            if (typeof Hands === 'undefined') {
                log('è­¦å‘Š: MediaPipe åº“åŠ è½½å»¶è¿Ÿã€‚');
            }

            btn.innerHTML = '<span class="animate-pulse">Loading...</span>';
            btn.disabled = true;
            ui.loadingText.style.display = 'block';
            
            try {
                fadeAudioIn();
                await initAudio();
                log('éŸ³é¢‘åˆå§‹åŒ–æˆåŠŸ');
            } catch(e) {
                log('éŸ³é¢‘åˆå§‹åŒ–è­¦å‘Š: ' + e);
                ui.statusText.innerText = "AUDIO/MIC LIMITED";
            }

            try {
                log('å°è¯•å¯åŠ¨æ‘„åƒå¤´...');
                await initCamera();
                log('æ‘„åƒå¤´å¯åŠ¨æˆåŠŸ');
            } catch (e) {
                log('æ‘„åƒå¤´/MediaPipe å¤±è´¥: ' + e);
                ui.statusText.innerText = "CAMERA FAILED - USE SPACEBAR";
            }
            
            log('è¿›å…¥ä¸»ç•Œé¢...');
            currentState = STATE.IDLE;
            ui.startOverlay.classList.add('hidden');
            ui.uiLayer.style.display = 'flex';

            // å¯åŠ¨è‡ªåŠ¨å€’æ•°
            startAutoEntryCountdown();
        });

        async function initAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                checkAudio();
            } catch (e) {
                log('éº¦å…‹é£æƒé™è¢«æ‹’ç»');
                ui.statusText.innerText = "MIC DENIED - USE TOUCH/SPACE";
                throw e;
            }
        }

        document.addEventListener('touchstart', (e) => {
            if(currentState === STATE.BLOWING && !e.target.closest('button') && !e.target.closest('input')) {
                isTouching = true;
            }
        }, {passive: false});

        document.addEventListener('touchend', () => isTouching = false);
        document.addEventListener('touchcancel', () => isTouching = false);
        document.addEventListener('keydown', (e) => { 
            if(e.code === 'Space') isSpacePressed = true;
            
            // é”®ç›˜å¿«æ·é”®æ§åˆ¶ï¼ˆç”¨äº file:// åè®®æˆ–æ‘„åƒå¤´ä¸å¯ç”¨æ—¶ï¼‰
            // æŒ‰ S é”®ï¼šæ•£å¼€è›‹ç³•
            if (e.code === 'KeyS' && (currentState === STATE.CAKE || currentState === STATE.BLOWING)) {
                e.preventDefault();
                if (!isCakeScattered) {
                    log('é”®ç›˜è§¦å‘ï¼šæ•£å¼€è›‹ç³•');
                    scatterCakeAndAddStars();
                }
            }
            // æŒ‰ R é”®ï¼šæ¢å¤è›‹ç³•
            if (e.code === 'KeyR' && currentState === STATE.SCATTERED) {
                e.preventDefault();
                log('é”®ç›˜è§¦å‘ï¼šæ¢å¤è›‹ç³•');
                returnToCake();
            }
            // æŒ‰ P é”®ï¼šåˆ‡æ¢ç…§ç‰‡æ˜¾ç¤ºï¼ˆæ¨¡æ‹Ÿå³æ‰‹æ¡æ‹³ï¼‰
            if (e.code === 'KeyP' && (currentState === STATE.CAKE || currentState === STATE.SCATTERED || currentState === STATE.BLOWING)) {
                e.preventDefault();
                if (currentPhotoIndex === -1) {
                    // æ˜¾ç¤ºç…§ç‰‡ï¼ˆéšæœºä½ç½®ï¼‰
                    const randomIndex = Math.floor(Math.random() * PHOTOS.length);
                    showPhoto(randomIndex, 0.5, 0.5);
                    log('é”®ç›˜è§¦å‘ï¼šæ˜¾ç¤ºç…§ç‰‡');
                } else {
                    // éšè—ç…§ç‰‡
                    hidePhoto();
                    log('é”®ç›˜è§¦å‘ï¼šéšè—ç…§ç‰‡');
                }
            }
        });
        document.addEventListener('keyup', (e) => { if(e.code === 'Space') isSpacePressed = false; });

        function checkAudio() {
            requestAnimationFrame(checkAudio);
            if (currentState !== STATE.BLOWING) return;
            let volume = 0;
            if (analyser) {
                const data = new Uint8Array(analyser.frequencyBinCount);
                analyser.getByteFrequencyData(data);
                let sum = 0; for(let i=0; i<data.length; i++) sum += data[i];
                volume = sum / data.length;
            }
            if (volume > VISUAL_CONFIG.blowThreshold || isSpacePressed || isTouching) {
                isBlowing = true;
                blowProgress += 0.8; 
            } else {
                isBlowing = false;
                blowProgress -= 0.3; 
            }
            blowProgress = Math.max(0, Math.min(100, blowProgress));
            ui.blowBar.style.width = blowProgress + '%';
            if (blowProgress >= 100) successCelebration();
        }

        function fadeAudioIn() {
            const playPromise = bgm.play();
            if (playPromise !== undefined) {
                playPromise.then(_ => {
                    log('èƒŒæ™¯éŸ³ä¹å¼€å§‹æ’­æ”¾');
                }).catch(error => {
                    log('è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢ï¼Œç­‰å¾…ç”¨æˆ·äº¤äº’');
                });
            }
            
            bgm.volume = 0;
            let vol = 0;
            const fade = setInterval(() => {
                vol += 0.05;
                if(vol >= 0.5) { vol = 0.5; clearInterval(fade); }
                bgm.volume = vol;
            }, 200);
        }
        
        document.getElementById('music-btn').addEventListener('click', () => {
            if (bgm.paused) bgm.play(); else bgm.pause();
        });

        async function initCamera() {
            const video = document.getElementsByClassName('input_video')[0];
            
            if (typeof Hands === 'undefined' || typeof Camera === 'undefined') {
                throw new Error("MediaPipe åº“æœªåŠ è½½");
            }

            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`});
            
            hands.setOptions({ 
                maxNumHands: 2, // æ”¯æŒä¸¤åªæ‰‹
                modelComplexity: 0, 
                minDetectionConfidence: 0.5, 
                minTrackingConfidence: 0.5 
            });
            
            hands.onResults((results) => {
                const ctx = document.getElementById('output_canvas').getContext('2d');
                ctx.clearRect(0, 0, 160, 120);
                
                let leftHand = null;
                let rightHand = null;
                let leftHandIndex = -1;
                let rightHandIndex = -1;
                
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    ui.camStatusDot.className = "w-1.5 h-1.5 rounded-full bg-green-400 shadow-[0_0_8px_#4ade80]";
                    ui.camStatusText.innerText = "DETECTED";
                    ui.camStatusText.className = "text-[8px] text-green-400 font-mono font-bold";
                    
                    // è¯†åˆ«å·¦å³æ‰‹
                    results.multiHandLandmarks.forEach((landmarks, index) => {
                        const handedness = results.multiHandedness[index];
                        if (handedness && handedness.length > 0) {
                            const label = handedness[0].label; // "Left" æˆ– "Right"
                            
                            if (label === "Left") {
                                leftHand = landmarks;
                                leftHandIndex = index;
                            } else if (label === "Right") {
                                rightHand = landmarks;
                                rightHandIndex = index;
                            }
                        }
                    });
                    
                    // ç»˜åˆ¶æ‰‹éƒ¨éª¨æ¶
                    results.multiHandLandmarks.forEach((landmarks, index) => {
                        const color = (index === leftHandIndex) ? '#ff69b4' : '#4ade80';
                        drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {color: color, lineWidth: 2});
                    });
                    
                    // åœ¨ IDLE çŠ¶æ€ä¸‹ï¼Œæ£€æµ‹åˆ°ä»»ä½•æ‰‹åŠ¿éƒ½è§¦å‘å€’è®¡æ—¶
                    if (currentState === STATE.IDLE) {
                        // æ£€æµ‹åˆ°æ‰‹åŠ¿ï¼Œè§¦å‘å€’è®¡æ—¶åºåˆ—
                        startSequence();
                    }
                    
                    // å¤„ç†å·¦æ‰‹æ‰‹åŠ¿ï¼ˆä»…åœ¨è›‹ç³•æ˜¾ç¤ºåï¼‰
                    if (leftHand && (currentState === STATE.CAKE || currentState === STATE.SCATTERED || currentState === STATE.BLOWING)) {
                        const isOpen = isHandOpen(leftHand);
                        const isFist = isHandFist(leftHand);
                        
                        // æ·»åŠ è°ƒè¯•ä¿¡æ¯
                        if (isOpen && lastLeftHandState !== 'open') {
                            log(`å·¦æ‰‹å¼ å¼€æ£€æµ‹åˆ° - å½“å‰çŠ¶æ€: ${currentState}, CAKEçŠ¶æ€: ${STATE.CAKE}`);
                            // å·¦æ‰‹äº”æŒ‡å¼ å¼€ -> æ•£å¼€è›‹ç³•å¹¶æ˜¾ç¤ºæ˜Ÿæ˜Ÿ
                            if (currentState === STATE.CAKE || currentState === STATE.BLOWING) {
                                log('è§¦å‘è›‹ç³•æ•£å¼€');
                                scatterCakeAndAddStars();
                            }
                            lastLeftHandState = 'open';
                        } else if (isFist && lastLeftHandState !== 'fist') {
                            // å·¦æ‰‹æ¡æ‹³ -> å›å½’è›‹ç³•å½¢çŠ¶
                            if (currentState === STATE.SCATTERED) {
                                log('è§¦å‘è›‹ç³•æ¢å¤');
                                returnToCake();
                            }
                            lastLeftHandState = 'fist';
                        } else if (!isOpen && !isFist) {
                            if (lastLeftHandState !== null) {
                                lastLeftHandState = null;
                            }
                        }
                    } else if (currentState !== STATE.CAKE && currentState !== STATE.SCATTERED && currentState !== STATE.BLOWING) {
                        lastLeftHandState = null;
                    }
                    
                    // å¤„ç†å³æ‰‹æ‰‹åŠ¿ï¼ˆä»…åœ¨è›‹ç³•æ˜¾ç¤ºåï¼‰
                    if (rightHand && (currentState === STATE.CAKE || currentState === STATE.SCATTERED || currentState === STATE.BLOWING)) {
                        const isOpen = isHandOpen(rightHand);
                        const isFist = isHandFist(rightHand);
                        const palm = rightHand[9]; // æ‰‹æŒä¸­å¿ƒ
                        
                        if (isFist && lastRightHandState !== 'fist') {
                            // å³æ‰‹æ¡æ‹³ -> åœ¨ä½ç½®æ˜¾ç¤ºç…§ç‰‡
                            const photoIndex = getPhotoIndexByPosition(rightHand);
                            showPhoto(photoIndex, palm.x, palm.y);
                            lastRightHandState = 'fist';
                        } else if (isOpen && lastRightHandState !== 'open') {
                            // å³æ‰‹å¼ å¼€äº”æŒ‡ -> éšè—ç…§ç‰‡
                            hidePhoto();
                            lastRightHandState = 'open';
                        } else if (isFist && lastRightHandState === 'fist') {
                            // å³æ‰‹ç§»åŠ¨æ—¶æ›´æ–°ç…§ç‰‡ä½ç½®
                            const photoIndex = getPhotoIndexByPosition(rightHand);
                            if (photoIndex !== currentPhotoIndex) {
                                showPhoto(photoIndex, palm.x, palm.y);
                            }
                        } else if (!isOpen && !isFist) {
                            lastRightHandState = null;
                        }
                    } else {
                        if (lastRightHandState === 'fist' && (currentState === STATE.CAKE || currentState === STATE.SCATTERED || currentState === STATE.BLOWING)) {
                            hidePhoto();
                        }
                        if (currentState !== STATE.CAKE && currentState !== STATE.SCATTERED && currentState !== STATE.BLOWING) {
                            lastRightHandState = null;
                        }
                    }
                    
                    // å…¼å®¹æ—§çš„æ‰‹åŠ¿æ§åˆ¶ï¼ˆå•åªæ‰‹æ—‹è½¬ï¼‰
                    if (interactionMode === 1 && results.multiHandLandmarks.length === 1) {
                        const currentHandX = results.multiHandLandmarks[0][9].x; 
                        const delta = currentHandX - lastHandX;
                        if (Math.abs(delta) > 0.002) {
                            rotationVelocity += delta * -0.4; 
                        }
                        lastHandX = currentHandX;
                    }
                } else {
                    ui.camStatusDot.className = "w-1.5 h-1.5 rounded-full bg-red-500";
                    ui.camStatusText.innerText = "NO HAND";
                    ui.camStatusText.className = "text-[8px] text-red-400 font-mono";
                    lastLeftHandState = null;
                    lastRightHandState = null;
                }
            });

            const camera = new Camera(video, { 
                onFrame: async () => { await hands.send({image: video}); }, 
                width: 320, 
                height: 240 
            });
            
            return camera.start();
        }

        function render() {
            requestAnimationFrame(render);
            updateParticles();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>